//
//  Transport.swift
//  Pathfinder
//
//  Created by Adam Michael on 10/15/15.
//  Copyright Â© 2015 Pathfinder. All rights reserved.
//

import Foundation
import CoreLocation

/**
A registered transport that can be routed to transport commodities.

This class should never be instantiated directly because it represents the state of the data from the Pathfinder backend. Instead, connect your device as a transport.
*/
public class Transport: NSObject {

  /// The delegate that will receive notifications when any aspect of the cluster is updated.
  public var delegate: TransportDelegate?

  /// The route to which the transport is currently assigned, if there is one.
  public var route: Route?

  /// The limiting capacities of each parameter that cannot be surpassed at any point of a route.
  public let capacities: [String:Int]

  /// The current state of the transports online/offline status.
  public var online: Bool = false

  /// The unique id of the transport, as generated by Pathfinder.
  public var id: Int?

  var cluster: Cluster!
  var locationManager: CLLocationManager?
  var location: CLLocationCoordinate2D?

  init(id: Int, capacities: [String:Int], location: CLLocationCoordinate2D) {
    self.id = id
    self.capacities = capacities
    self.location = location
  }

  init(cluster: Cluster, capacities: [String:Int]) {
    self.cluster = cluster
    self.capacities = capacities
  }

  init(cluster: Cluster, id: Int, capacities: [String:Int]) {
    self.cluster = cluster
    self.id = id
    self.capacities = capacities
  }

  init(clusterId: Int, id: Int, capacities: [String:Int], location: CLLocationCoordinate2D) {
    self.id = id
    self.capacities = capacities
    self.location = location
  }

  /// Connects the local transport instance to the Pathfinder backend. Location updates will be send periodically to aid in routing calculations.
  public func connect() {
    locationManager = CLLocationManager()
    locationManager?.delegate = self
    locationManager?.desiredAccuracy = kCLLocationAccuracyBest
    locationManager?.requestAlwaysAuthorization()
    locationManager?.startUpdatingLocation()
  }

  public func subscribe() {

  }

  /**
  Retrieve the next action that the driver of the transport will need to undertake. Currently, this is only pickups and dropoffs of commodities. If you want the entire queue of upcoming events, see the route field.

  - seealso: route
  */
  public func nextRouteAction() -> RouteAction? {
    return nil
  }

  ///Indicates that a transport has successfully completed one route action. It is the transports responsibility to indicate that they have picked up and dropped off their commodities. This method must be called, preferrably as the result of a UI interaction, when the driver acknowledges that they have picked up or dropped off a commodity on their route.
  public func completeNextRouteAction() {

  }

  /**
  Removes the transport from the set of active transports that can be routed. If the transport is on route to pick up commodities, all of those commodities will be rerouted with a new transport. If the transport is currently transporting passengers, it cannot go offline.

  - Returns: True if the transport is successfully turned offline.
  */
  public func goOffline() -> Bool {
    return false
  }

  class func parse(message: NSDictionary) -> Transport? {
    if let id = message["id"] as? Int {
      if let capacity = message["capacity"] as? Int {
        if let latitude = message["latitude"] as? Double {
          if let longitude = message["longitude"] as? Double {
            let capacities = ["chimney": capacity]
            return Transport(id: id, capacities: capacities, location: CLLocationCoordinate2D(latitude: latitude, longitude: longitude))
          }
        }
      }
    }
    return nil
  }
}

class TransportResponse {
  let id: Int
  let location: CLLocationCoordinate2D
  let capacity: Int

  class func parse(message: NSDictionary) -> TransportResponse? {
    if let update = message["updated"] as? NSDictionary {
      if update["model"] as? String == "Vehicle" {
        let value = update["value"] as! NSDictionary
        let id = value["id"] as! Int
        let lat = value["latitude"] as! Double
        let lng = value["longitude"] as! Double
        return TransportResponse(id: id, location: CLLocationCoordinate2D(latitude: lat, longitude: lng), capacity: 3)
      }
    }
    if let update = message["created"] as? NSDictionary {
      if update["model"] as? String == "Vehicle" {
        let value = update["value"] as! NSDictionary
        let id = value["id"] as! Int
        let lat = value["latitude"] as! Double
        let lng = value["longitude"] as! Double
        return TransportResponse(id: id, location: CLLocationCoordinate2D(latitude: lat, longitude: lng), capacity: 3)
      }
    }
    return nil
  }

  init(id: Int, location: CLLocationCoordinate2D, capacity: Int) {
    self.id = id
    self.location = location
    self.capacity = capacity
  }
}

extension Transport: CLLocationManagerDelegate {

  public func locationManager(manager: CLLocationManager, didChangeAuthorizationStatus status: CLAuthorizationStatus) {
    print("LocationManager authorization status changed: \(status)")
    if status == CLAuthorizationStatus.AuthorizedAlways {
      self.cluster.connect() { (cluster: Cluster) -> Void in
        self.cluster.conn.create(self) { (resp: TransportResponse) -> Void in
          self.id = resp.id
          self.cluster.conn.subscribe(self)
        }
      }
    }
  }

  public func locationManager(manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {
    print("Transport location updated to \(locations[0].coordinate)")
    location = locations[0].coordinate
    if id != nil {
      cluster.conn.update(self) { _ in }
    }
  }
}