//
//  Cluster.swift
//  Pathfinder
//
//  Created by Adam Michael on 10/15/15.
//  Copyright Â© 2015 Pathfinder. All rights reserved.
//

import Foundation
import CoreLocation

/**
A container in which vehicles are routed to transport commodities. Every registered Pathfinder application is created one default cluster. Additional sub-clusters can be created by the developer through the Pathfinder web interface.

This class should not be instantiated directly since it represents the state of the Pathfinder backend service. Instead, use the factory methods in the Pathfinder class. The typical use case of creating a Cluster object is to set a delegate for it which will receive all of the updates defined in `ClusterDelegate`.
*/
public class Cluster {

  /// The delegate that will receive notifications when any aspect of the cluster is updated.
  public var delegate: ClusterDelegate?

  /// The unique id of the cluster, as generated by Pathfinder.
  public var id: Int?

  /// The vehicles that are currently online within the cluster.
  public var vehicles: [Vehicle]

  /// The commodities that are currently waiting on transit or are in transit within the cluster.
  public var commodities: [Commodity]

  /// All of the routes that are currently in progress for the cluster.
  public let routes: [Route]

  /// True if the connection to Pathfinder is active.
  public var connected: Bool

  let conn: PathfinderConnection

  init(conn: PathfinderConnection) {
    self.vehicles = [Vehicle]()
    self.commodities = [Commodity]()
    self.routes = [Route]()
    self.conn = conn
    self.connected = false
  }

  init(conn: PathfinderConnection, id: Int) {
    self.id = id
    self.vehicles = [Vehicle]()
    self.commodities = [Commodity]()
    self.routes = [Route]()
    self.conn = conn
    self.connected = true
  }

  //// Attempts to authenticate and retrieve a reference to the requested cluster. If the connection succeeds, the corresponding method on the delegate will be executed. This method should only be utilized if you wish to receive updates on all commodities, vehicles and routes for the entire cluster.
  public func connect() {
    connect { _ in }
  }

  /**
  Registers the current device as a vehicle with the Pathfinder service or uses the user's authentication to determine if an existing vehicle record exists and retrieves it. This will NOT set the vehicle to the online state. No routes will be generated for the vehicle until it is set to online. If the connection is authenticated and succeeds, the corresponding method on the delegate will be executed.

  - Parameter capacities:  The limiting constraints of the vehicle of the parameters of your application's routing calculations. The set of parameters needs to be defined and prioritized via the Pathfinder web interface in advance. All vehicles will be routed while keeping their sum occupant parameters to be less than or equal to their limiting constraints.
  - Parameter callback:    This function will be called exactly once with the registered Vehicle object. The Vehicle object can be used to set the vehicle as online or offline, to receive route assignments and send updates regarding pickups and dropoffs.
  */
  public func createVehicle(parameterCapacities: [String:Int]) -> Vehicle {
    return Vehicle(cluster: self, capacities: parameterCapacities)
  }

  /**
   Requests transportation for a physical entity from one geographical location to another. This will immediately route a vehicle to pick up the commodity if one is available that can hold the commodities parameters within the vehicles capacity. If the connection is authenticated and succeeds, the corresponding method on the delegate of the returned commodity will be executed.

   - Parameter start:        The starting location of the commodity.
   - Parameter destination:  The destination location of the commodity.
   - Parameter parameters:   The quantities the parameters of your application's routing calculations. The set of parameters needs to be defined and prioritized via the Pathfinder web interface in advance.
   - Parameter callback:    This function will be called exactly once with the created Commodity object. The Commodity object can be used to receive updates on status, routes and cancel the request if needed.
   */
  public func createCommodity(start: CLLocationCoordinate2D, destination: CLLocationCoordinate2D, parameters: [String:Int]) -> Commodity {
    return Commodity(cluster: self, start: start, destination: destination, parameters: parameters)
  }

  func connect(callback: (cluster: Cluster) -> Void) {
    if !connected {
      if id != nil {
        conn.getClusterById(id!) { (resp: ClusterResponse) -> Void in
          self.connected = true
          self.id = resp.id
          self.vehicles = resp.vehicles
          self.commodities = resp.commodities
          self.delegate?.connectedTo(self)
          callback(cluster: self)
        }
      } else {
        conn.getDefaultCluster { (appResp: ApplicationResponse) -> Void in
          self.conn.getClusterById(appResp.defaultId) { (resp: ClusterResponse) -> Void in
            self.connected = true
            self.id = resp.id
            self.vehicles = resp.vehicles
            self.commodities = resp.commodities
            self.delegate?.connectedTo(self)
            callback(cluster: self)
          }
        }
      }
    }
  }
}

class ApplicationResponse {
  let defaultId: Int
  let clusterIds: [Int]

  class func parse(message: NSDictionary) -> ApplicationResponse? {
    if let value: NSDictionary = message["applicationCluster"] as? NSDictionary {
      let clusterId = value["clusterId"] as! Int
      return ApplicationResponse(defaultId: clusterId, clusterIds: [Int]())
    }
    return nil
  }

  init(defaultId: Int, clusterIds: [Int]) {
    self.defaultId = defaultId
    self.clusterIds = clusterIds
  }
}

class ClusterResponse {
  let id: Int
  let vehicles: [Vehicle]
  let commodities: [Commodity]

  class func parse(message: NSDictionary) -> ClusterResponse? {
    if let model: NSDictionary = message["model"] as? NSDictionary {
      if model["model"] as? String == "Cluster" {
        if let value: NSDictionary = model["value"] as? NSDictionary {
          let clusterId = value["id"] as! Int
          let vehicles = (value["vehicles"] as! NSArray).map() { (anyObj: AnyObject) -> Vehicle in
            let vehicleDict = anyObj as! NSDictionary
            let id = vehicleDict["id"] as! Int
            let capacities = ["chimney":vehicleDict["capacity"] as! Int]
            let location = CLLocationCoordinate2D(latitude: vehicleDict["latitude"] as! Double, longitude: vehicleDict["longitude"] as! Double)
            return Vehicle(clusterId: clusterId, id: id, capacities: capacities, location: location)
          }
          let commodities = (value["commodities"] as! NSArray).map() { (anyObj: AnyObject) -> Commodity in
            let commodityDict = anyObj as! NSDictionary
            let id = commodityDict["id"] as! Int
            let start = CLLocationCoordinate2D(latitude: commodityDict["startLatitude"] as! Double, longitude: commodityDict["startLongitude"] as! Double)
            let destination = CLLocationCoordinate2D(latitude: commodityDict["endLatitude"] as! Double, longitude: commodityDict["endLongitude"] as! Double)
            let parameters = ["chimney":commodityDict["param"] as! Int]
            return Commodity(clusterId: clusterId, id: id, start: start, destination: destination, parameters: parameters)
          }
          return ClusterResponse(id: clusterId, vehicles: vehicles, commodities: commodities)
        }
      }
    }
    return nil
  }

  init(id: Int, vehicles: [Vehicle], commodities: [Commodity]) {
    self.id = id
    self.vehicles = vehicles
    self.commodities = commodities
  }
}