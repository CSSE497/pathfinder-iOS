//
//  Commodity.swift
//  Pathfinder
//
//  Created by Adam Michael on 10/15/15.
//  Copyright Â© 2015 Pathfinder. All rights reserved.
//

import Foundation
import CoreLocation

/**
A commodity that has requested transportation via your application.

This class should never be instantiated directly because it represents the state of the data from the Pathfinder backend. Instead, request commodity transportation via the helper method in the Pathfinder class.
 
A typical use case looks like this:

```swift
let clusterToRouteIn = self.cluster
let start = CLLocationCoordinate2D(latitude: startLat, longitude: startLng)
let end = CLLocationCoordinate2D(latitude: endLat, longitude: endLng)
let parameters = [String:Int]()
parameters["people"] = 2
parameters["sheep"] = 0
let commodity = pathfinder.cluster("/USA/West/Seattle").createCommodity(start, destination: end, parameters: parameters)
commodity.connect()
commodity.request()
```

The primary purpose of creating a commodity is to set its delegate. The delegate will receive updates on the status of the commodity as defined in `CommodityDelegate`.
*/
public class Commodity {

  // MARK: - Enums -

  /// All commodities exist in one of five states: inactive, waiting, picked up, dropped off or cancelled.
  public enum Status: CustomStringConvertible {
    case Inactive
    case Waiting
    case PickedUp
    case DroppedOff
    case Cancelled

    public var description: String {
      switch self {
      case .Inactive: return "Inactive"
      case .Waiting: return "Waiting"
      case .PickedUp: return "PickedUp"
      case .DroppedOff: return "DroppedOff"
      case .Cancelled: return "Cancelled"
      }
    }
  }

  // MARK: - Instance Variables

  /// The delegate that will receive notifications when any aspect of the commodity is updated.
  public var delegate: CommodityDelegate?

  /// The unique id of the transport, as generated by Pathfinder.
  public var id: Int?

  /// The starting location of the commodity's journey.
  public var start: CLLocationCoordinate2D?

  /// The destination location of the commodity's journey.
  public var destination: CLLocationCoordinate2D?

  /// The parameters that constrain the number of commodities that can be transported by one transport.
  public var parameters: [String:Int]?

  /// The route that is assigned to pick up the commodity, if there is one.
  public var route: Route?

  /// The current status of the commodity. All commodities are inactive upon creation.
  public var status: Status = Status.Inactive

  var cluster: Cluster!

  // MARK: - Methods -

  /// Requests transportation for the current commodity.
  public func request() {
    cluster!.connect() { (cluster: Cluster) -> Void in
      self.cluster.conn.create(self) { (resp: CommodityResponse) -> Void in
        self.id = resp.id
      }
    }
  }

  /// Validates and authenticates the Pathfinder connection to the backend data for this instance. If the connection is successful, the corresponding method on the delegate is called. Upon completion, all instance variables will be updated with the data from the Pathfinder service.
  public func connect() {
  }

  /**
  Subscribes to push notifications for all updates to the commodity. The corresponding method on the delegate will be called for the following events:
   
  * Commodity was assigned to a route.
  * Commodity was picked up, dropped off or the request was cancelled.
  */
  public func subscribe() {
    self.cluster.conn.subscribe(self)
  }

  /// Stops the Pathfinder service from sending update notifications.
  public func unsubscribe() {

  }

  /**
  Updates the commodity's status. This can be used to cancel the transportation request or to indicate that the commodity was picked up or dropped off by the vehicle. Commodities are created with status `Inactive`.
   
  - Parameter status:  The new status of the vehicle.
  */
  public func update(status: Status) {
    self.cluster.conn.update(self) { (resp: CommodityResponse) -> Void in
      
    }
  }

  init(cluster: Cluster, id: Int) {
    self.cluster = cluster
    self.id = id
  }

  init(id: Int, start: CLLocationCoordinate2D, destination: CLLocationCoordinate2D, parameters: [String:Int]) {
    self.id = id
    self.start = start
    self.destination = destination
    self.parameters = parameters
  }

  init(cluster: Cluster, start: CLLocationCoordinate2D, destination: CLLocationCoordinate2D, parameters: [String:Int]) {
    self.cluster = cluster
    self.start = start
    self.destination = destination
    self.parameters = parameters
  }

  init(cluster: Cluster, id: Int, start: CLLocationCoordinate2D, destination: CLLocationCoordinate2D, parameters: [String:Int]) {
    self.cluster = cluster
    self.id = id
    self.start = start
    self.destination = destination
    self.parameters = parameters
  }

  init(clusterId: Int, id: Int, start: CLLocationCoordinate2D, destination: CLLocationCoordinate2D, parameters: [String:Int]) {
    self.id = id
    self.start = start
    self.destination = destination
    self.parameters = parameters
  }

  class func parse(message: NSDictionary) -> Commodity? {
    if let startLat = message["startLatitude"] as? Double {
      if let startLng = message["startLongitude"] as? Double {
        if let endLat = message["endLatitude"] as? Double {
          if let endLng = message["endLongitude"] as? Double {
            if let id = message["id"] as? Int {
              if let param = message["param"] as? Int {
                let start = CLLocationCoordinate2D(latitude: startLat, longitude: startLng)
                let end = CLLocationCoordinate2D(latitude: endLat, longitude: endLng)
                let parameters = ["chimney":param]
                return Commodity(id: id, start: start, destination: end, parameters: parameters)
              }
            }
          }
        }
      }
    }
    return nil
  }
}